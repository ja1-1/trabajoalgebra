# Archivo Python: Soluciones Laboratorio 2025 Version 5

import numpy as np
from sympy import symbols, Matrix, det, simplify, solve, Eq

# -------------------------------
# Ejercicio 1
# -------------------------------
# Datos
u = np.array([24, 1, 6])
v = np.array([19, 37, -1])
w = np.array([34, -46, 7])
z = np.array([13, -4, 28])

# a) Producto punto
A = u + z - v
B = z - 3*w + v
resultado_a = np.dot(A, B)

# b) Normas y producto cruzado
C = z - w
norma_C = np.linalg.norm(C)
producto_cruzado = np.cross(w, u)
norma_cruzado = np.linalg.norm(producto_cruzado)
resultado_b = norma_C - norma_cruzado

# c) Expresión combinada
norma_u = np.linalg.norm(u)
suma_vz = v + z
producto1 = norma_u * suma_vz
expresion2 = 2*z - 3*w
norma_exp2 = np.linalg.norm(expresion2)
producto2 = norma_exp2 * z
resultado_c = producto1 + producto2

# d) Descomposición paralela y ortogonal
u_sym = Matrix(u)
v_sym = Matrix(v)
lambda_proj = (v_sym.dot(u_sym)) / (u_sym.dot(u_sym))
p = np.array(lambda_proj * np.array(u), dtype=float)  # Ajuste para evitar errores de tipo
h = v - p

# -------------------------------
# Ejercicio 2
# -------------------------------
# Matriz de codificación
llave = [0, 0, 1, -1, 0, 0, 4, -1, 1, 2, -2, 4, 1, 1, 2, 2, -4, 0, 0, -2, 0, 2, -1, 1, 2]
A = np.array(llave).reshape((5, 5))

# Validar si la matriz es invertible
if np.linalg.det(A) == 0:
    raise ValueError("La matriz A no es invertible.")

# Mensaje codificado
mensaje_codificado = [
    -27, 11, 2, -3, 12, -12, 25, 3, 9, -2, 23, -3, -11, -10, -9, 17, 17, 1, -7, -16,
    -20, -15, 49, 139, 70, 63, 80, 180, 25, 49, 79, 16, 39, 95, 93, 150, 99, 57, 133, 21,
    47, 130, 24, 123, 27, 193, 20, 69, 96, 184, 39, 83, 51, 6, 51, 117, 89, 140, 127, 43,
    149, 17, 9, 122, -18, 79, 2, -148, -16, -34, -82, -140, -8, -42, -32, -2, -18, -82,
    -44, -98, -80, -18, -122, 10, 16, -98, 40, -56, 39, 83, 62, 53, 56, 124, 17, 39, 39, 14,
    27, 77, 61, 94, 75, 25, 77, 19, 43, 92, 22, 69
]
C = np.array(mensaje_codificado).reshape((5, -1))

# Mensaje decodificado
A_inv = np.linalg.inv(A)
B = np.matmul(A_inv, C)
B_redondeado = np.round(B).astype(int) % 26
mensaje = ''.join(chr(n + ord('A')) for n in B_redondeado.flatten())

# -------------------------------
# Ejercicio 3
# -------------------------------
k = symbols('k')
A_k = Matrix([
    [-k, k-1, k+1, k, 0],
    [1, 2, -2, -1, 1],
    [4-k, k, k+3, -k, 1],
    [-2, 3, 4, 6, 2],
    [0, 2, 1, 0, 4]
])

det_A_k = simplify(A_k.det())
soluciones_inversa = solve(Eq(det_A_k, 0), k)
soluciones_det5_3k = solve(Eq(det_A_k, 5 - 3*k), k)

# -------------------------------
# Ejercicio 4
# -------------------------------
# a) Área del triángulo
M_a = Matrix([
    [1, -3, 1],
    [-1, 5, 1],
    [-7, -4, 1]
])
area_a = (1/2) * abs(M_a.det())

# b) Área cuadrada igual 81
M_b = Matrix([
    [k, -2, 1],
    [k, 1, 1],
    [-1, k, 1]
])
det_M_b = simplify(M_b.det())

# Resolver (1/2 * |det|)^2 = 81
sol1 = solve(3*k + 3 - 18, k)
sol2 = solve(3*k + 3 + 18, k)

# -------------------------------
# Ejercicio 5
# -------------------------------
v1 = (1, 1, 1, -1, 0, 1)
v2 = (1, 0, -1, 0, -1, 0)
v3 = (0, 0, 0, -1, -2, 0)
v4 = (1, 1, 0, -1, 0, 1)
v5 = (0, 0, 1, 1, 1, -1)
v6 = (0, 1, 1, -1, 0, 1)

M5 = Matrix.hstack(Matrix(v1), Matrix(v2), Matrix(v3), Matrix(v4), Matrix(v5), Matrix(v6))
rango_M5 = M5.rank()

v_objetivo = Matrix([7, -3, 6, 1, 4, -5])
coeficientes = M5.LUsolve(v_objetivo)

# -------------------------------
# Ejercicio 6
# -------------------------------
# a) Neutro aditivo
neutro = np.array([-2, -2])
vector_prueba = np.array([5, 33])
suma_neutro = neutro + vector_prueba

# b) 8 \odot [(-11,3) \oplus (5,-7)]
suma_interna = np.array([-11, 3]) + np.array([5, -7])
res_b = 8 * suma_interna

# c) 8 \odot (-11,3) \oplus 8 \odot (5,-7)
res_1 = 8 * np.array([-11, 3])
res_2 = 8 * np.array([5, -7])
suma_final = res_1 + res_2

# d) Conclusión
espacio_vectorial = False

# -------------------------------
# Fin del archivo de soluciones